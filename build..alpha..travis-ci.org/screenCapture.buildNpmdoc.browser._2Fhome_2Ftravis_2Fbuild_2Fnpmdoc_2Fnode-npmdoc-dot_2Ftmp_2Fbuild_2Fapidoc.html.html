<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/olado/doT">dot (v1.1.1)</a>
</h1>
<h4>Concise and fast javascript templating compatible with nodejs and other javascript environments</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.dot">module dot</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">dot.</span>log</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.compile">
            function <span class="apidocSignatureSpan">dot.</span>compile
            <span class="apidocSignatureSpan">(tmpl, def)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.encodeHTMLSource">
            function <span class="apidocSignatureSpan">dot.</span>encodeHTMLSource
            <span class="apidocSignatureSpan">(doNotSkipEncoded)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.process">
            function <span class="apidocSignatureSpan">dot.</span>process
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.template">
            function <span class="apidocSignatureSpan">dot.</span>template
            <span class="apidocSignatureSpan">(tmpl, c, def)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dot.</span>doU</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dot.</span>jslitmus</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dot.</span>templateSettings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">dot.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.dot.doU">module dot.doU</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.doU.template">
            function <span class="apidocSignatureSpan">dot.doU.</span>template
            <span class="apidocSignatureSpan">(tmpl, conf)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dot.doU.</span>templateSettings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">dot.doU.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.dot.jslitmus">module dot.jslitmus</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.Test">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>Test
            <span class="apidocSignatureSpan">(name, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.clearAll">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>clearAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.emit">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>emit
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.getGoogleChart">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>getGoogleChart
            <span class="apidocSignatureSpan">(normalize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.on">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>on
            <span class="apidocSignatureSpan">(e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.removeAllListeners">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>removeAllListeners
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.removeListener">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>removeListener
            <span class="apidocSignatureSpan">(e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.runAll">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>runAll
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.dot.jslitmus.test">
            function <span class="apidocSignatureSpan">dot.jslitmus.</span>test
            <span class="apidocSignatureSpan">(name, f)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dot.jslitmus.</span>platform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">dot.jslitmus.</span>unsupported</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dot" id="apidoc.module.dot">module dot</a></h1>




    <h2>
        <a href="#apidoc.element.dot.compile" id="apidoc.element.dot.compile">
        function <span class="apidocSignatureSpan">dot.</span>compile
        <span class="apidocSignatureSpan">(tmpl, def)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (tmpl, def) {
		return doT.template(tmpl, null, def);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.encodeHTMLSource" id="apidoc.element.dot.encodeHTMLSource">
        function <span class="apidocSignatureSpan">dot.</span>encodeHTMLSource
        <span class="apidocSignatureSpan">(doNotSkipEncoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeHTMLSource = function (doNotSkipEncoded) {
		var encodeHTMLRules = { "&amp;": "&amp;#38;", "&lt;": "&amp;#60;", "&gt;": "&amp;#62;", '"': "&amp;#34;", "'": "&amp;#39;", "/": "&amp;#47;" },
			matchHTML = doNotSkipEncoded ? /[&amp;&lt;&gt;"'\/]/g : /&amp;(?!#?\w+;)|&lt;|&gt;|"|'|\//g;
		return function(code) {
			return code ? code.toString().replace(matchHTML, function(m) {return encodeHTMLRules[m] || m;}) : "";
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.process" id="apidoc.element.dot.process">
        function <span class="apidocSignatureSpan">dot.</span>process
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (options) {
	//path, destination, global, rendermodule, templateSettings
	return new InstallDots(options).compileAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		&lt;div&gt;{{=param.foo}}&lt;/div&gt;
	#}}

	{{#def.macro:myvariable}}

####Node module now supports auto-compilation of dot templates from specified path

	var dots = require("dot").<span class="apidocCodeKeywordSpan">process</span>({ path: "./views"});

This will compile .def, .dot, .jst files found under the specified path.
Details
* It ignores sub-directories.
* Template files can have multiple extensions at the same time.
* Files with .def extension can be included in other files via {{#def.name}}
* Files with .dot extension are compiled into functions with the same name and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.template" id="apidoc.element.dot.template">
        function <span class="apidocSignatureSpan">dot.</span>template
        <span class="apidocSignatureSpan">(tmpl, c, def)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">template = function (tmpl, c, def) {
		c = c || doT.templateSettings;
		var cse = c.append ? startend.append : startend.split, needhtmlencode, sid = 0, indv,
			str  = (c.use || c.define) ? resolveDefs(c, tmpl, def || {}) : tmpl;

		str = ("var out='" + (c.strip ? str.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g," ")
					.replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""): str)
			.replace(/'|\\/g, "\\$&amp;")
			.replace(c.interpolate || skip, function(m, code) {
				return cse.start + unescape(code) + cse.end;
			})
			.replace(c.encode || skip, function(m, code) {
				needhtmlencode = true;
				return cse.startencode + unescape(code) + cse.end;
			})
			.replace(c.conditional || skip, function(m, elsecase, code) {
				return elsecase ?
					(code ? "';}else if(" + unescape(code) + "){out+='" : "';}else{out+='") :
					(code ? "';if(" + unescape(code) + "){out+='" : "';}out+='");
			})
			.replace(c.iterate || skip, function(m, iterate, vname, iname) {
				if (!iterate) return "';} } out+='";
				sid+=1; indv=iname || "i"+sid; iterate=unescape(iterate);
				return "';var arr"+sid+"="+iterate+";if(arr"+sid+"){var "+vname+","+indv+"=-1,l"+sid+"=arr"+sid+".length-1;while("+indv+"&lt;l"+
sid+"){"
					+vname+"=arr"+sid+"["+indv+"+=1];out+='";
			})
			.replace(c.evaluate || skip, function(m, code) {
				return "';" + unescape(code) + "out+='";
			})
			+ "';return out;")
			.replace(/\n/g, "\\n").replace(/\t/g, '\\t').replace(/\r/g, "\\r")
			.replace(/(\s|;|\}|^|\{)out\+='';/g, '$1').replace(/\+''/g, "");
			//.replace(/(\s|;|\}|^|\{)out\+=''\+/g,'$1out+=');

		if (needhtmlencode) {
			if (!c.selfcontained &amp;&amp; _globals &amp;&amp; !_globals._encodeHTML) _globals._encodeHTML = doT.encodeHTMLSource(c.doNotSkipEncoded);
			str = "var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : ("
				+ doT.encodeHTMLSource.toString() + "(" + (c.doNotSkipEncoded || '') + "));"
				+ str;
		}
		try {
			return new Function(c.varname, str);
		} catch (e) {
			<span class="apidocCodeCommentSpan">/* istanbul ignore else */
</span>			if (typeof console !== "undefined") console.log("Could not create a template function: " + str);
			throw e;
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

InstallDots.prototype.compileToFile = function(path, template, def) {
	def = def || {};
	var modulename = path.substring(path.lastIndexOf("/")+1, path.lastIndexOf("."))
		, defs = copy(this.__includes, copy(def))
		, settings = this.__settings || doT.templateSettings
		, compileoptions = copy(settings)
		, defaultcompiled = doT.<span class="apidocCodeKeywordSpan">template</span>(template, settings, defs)
		, exports = []
		, compiled = ""
		, fn;

	for (var property in defs) {
		if (defs[property] !== def[property] &amp;&amp; defs[property] !== this.__includes[property]) {
			fn = undefined;
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dot.doU" id="apidoc.module.dot.doU">module dot.doU</a></h1>


    <h2>
        <a href="#apidoc.element.dot.doU.template" id="apidoc.element.dot.doU.template">
        function <span class="apidocSignatureSpan">dot.doU.</span>template
        <span class="apidocSignatureSpan">(tmpl, conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">template = function (tmpl, conf) {
		conf = conf || doU.templateSettings;
		var str = '', tb = conf.begin, te = conf.end, m, l,
			arr = tmpl.replace(/\s*&lt;!\[CDATA\[\s*|\s*\]\]&gt;\s*|[\r\n\t]|(\/\*[\s\S]*?\*\/)/g, '')
				.split(tb).join(te +'\x1b')
				.split(te);

		for (m=0,l=arr.length; m &lt; l; m++) {
			str += arr[m].charAt(0) !== '\x1b' ?
			"out+='" + arr[m].replace(/(\\|["'])/g, '\\$1') + "'" : (arr[m].charAt(1) === '=' ?
			';out+=(' + arr[m].substr(2) + ');' : (arr[m].charAt(1) === '!' ?
			';out+=(' + arr[m].substr(2) + ").toString().replace(/&amp;(?!\\w+;)/g, '&amp;#38;').split('&lt;').join('&amp;#60;').split('&gt;').join('&amp;#62;').
split('" + '"' + "').join('&amp;#34;').split(" + '"' + "'" + '"' + ").join('&amp;#39;').split('/').join('&amp;#x2F;');" : ';' + arr[m].substr
(1)));
		}

		str = ('var out="";'+str+';return out;')
			.split("out+='';").join('')
			.split('var out="";out+=').join('var out=');

		try {
			return new Function(conf.varname, str);
		} catch (e) {
			if (typeof console !== 'undefined') console.log("Could not create a template function: " + str);
			throw e;
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

InstallDots.prototype.compileToFile = function(path, template, def) {
	def = def || {};
	var modulename = path.substring(path.lastIndexOf("/")+1, path.lastIndexOf("."))
		, defs = copy(this.__includes, copy(def))
		, settings = this.__settings || doT.templateSettings
		, compileoptions = copy(settings)
		, defaultcompiled = doT.<span class="apidocCodeKeywordSpan">template</span>(template, settings, defs)
		, exports = []
		, compiled = ""
		, fn;

	for (var property in defs) {
		if (defs[property] !== def[property] &amp;&amp; defs[property] !== this.__includes[property]) {
			fn = undefined;
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.dot.jslitmus" id="apidoc.module.dot.jslitmus">module dot.jslitmus</a></h1>


    <h2>
        <a href="#apidoc.element.dot.jslitmus.Test" id="apidoc.element.dot.jslitmus.Test">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>Test
        <span class="apidocSignatureSpan">(name, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Test(name, f) {
  var test = this;

  // Test instances get EventEmitter API
  EventEmitter.call(test);

  if (!f) throw new Error('Undefined test function');
  if (!/function[^\(]*\(([^,\)]*)/.test(f)) {
    throw new Error('"' + name + '" test: Invalid test function');
  }

  // If the test function takes an argument, we assume it does the iteration
  // for us
  var isLoop = !!RegExp.$1;

<span class="apidocCodeCommentSpan">  /**
   * Reset test state
   */
</span>  function reset() {
    delete test.count;
    delete test.time;
    delete test.running;
    test.emit('reset', test);
    return test;
  }

  function clone() {
    var test = extend(new Test(name, f), test);
    return test.reset();
  }

  /**
   * Run the test n times, and use the best results
   */
  function bestOf(n) {
    var best = null;
    while (n--) {
      var t = clone();
      t.run(null, true);
      if (!best || t.period &lt; best.period) {
        best = t;
      }
    }
    extend(test, best);
  }

  /**
   * Start running a test.  Default is to run the test asynchronously (via
   * setTimeout).  Can be made synchronous by passing true for 2nd param
   */
  function run(count, synchronous) {
    count = count || test.INIT_COUNT;
    test.running = true;

    if (synchronous) {
      _run(count, synchronous);
    } else {
      setTimeout(function() {
        _run(count);
      }, 1);
    }
    return test;
  }

  /**
   * Run, for real
   */
  function _run(count, noTimeout) {

    try {
      var start, f = test.f, now, i = count;

      // Start the timer
      start = new Date();

      // Run the test code
      test.count = count;
      test.time = 0;
      test.period = 0;

      test.emit('start', test);

      if (isLoop) {
        // Test code does it's own iteration
        f(count);
      } else {
        // Do the iteration ourselves
        while (i--) f();
      }

      // Get time test took (in secs)
      test.time = Math.max(1,new Date() - start)/1000;

      // Store iteration count and per-operation time taken
      test.count = count;
      test.period = test.time/count;

      // Do we need to keep running?
      test.running = test.time &lt; test.MIN_TIME;

      // Publish results
      test.emit('results', test);

      // Set up for another run, if needed
      if (test.running) {
        // Use an iteration count that will (we hope) get us close to the
        // MAX_COUNT time.
        var x = test.MIN_TIME/test.time;
        var pow = Math.pow(2, Math.max(1, Math.ceil(Math.log(x)/Math.log(2))));
        count *= pow;
        if (count &gt; test.MAX_COUNT) {
          throw new Error('Max count exceeded.  If this test uses a looping function, make sure the iteration loop is working properly
.');
        }

        if (noTimeout) {
          _run(count, noTimeout);
        } else {
          run(count);
        }
      } else {
        test.emit('complete', test);
      }
    } catch (err) {
      log(err);
      // Exceptions are caught and displayed in the test UI
      test.emit('error', err);
    }

    return test;
  }

  /**
  * Get the number of operations per second for this test.
  *
  * @param normalize if true, iteration loop overhead taken into account.
  *                  Note that normalized tests may return Infinity if the
  *                  test time is of the same order as the calibration time.
  */
  function getHz(normalize) {
    var p = test.period;

    // Adjust period based on the calibration test time
    if (normalize) {
      var cal = test.isLoop ? Test.LOOP_CAL : Test.NOLOOP_CAL;
      if (!cal.period) {
        // Run calibration if needed
        cal.MIN_TIME = .3;
        cal.bestOf(3);
      }

      // Subtract off calibration time.  In theory this should never be
      // negative, but in practice the calibration times are affected by a
      // variety of factors so just clip to zero and let users test for
      // getHz() == Infinity
      p = Math.max(0, p - cal.period);
    }

    return sig(1/p, 4);
  }

  // Set properties that are specific to this instance
  extend(test, {
    // Test name
    name: name, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.clearAll" id="apidoc.element.dot.jslitmus.clearAll">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>clearAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearAll() {
	tests = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				for(var i=0; i&lt;3; i++) { snippet += snippet; }
				console.log("*** Large template length: " + snippet.length);
				break;
			default:
				return;
			}

			jslitmus.<span class="apidocCodeKeywordSpan">clearAll</span>();
			testsetup(snippet);
			jslitmus.runAll();
		});
		// Run it!
		jslitmus.runAll();
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.emit" id="apidoc.element.dot.jslitmus.emit">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>emit
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (e) {
  var args = Array.prototype.slice.call(arguments, 1);
  forEach([].concat(listeners[e], listeners['*']), function(l) {
    ee._emitting = e;
    if (l) l.apply(ee, args);
  });
  delete ee._emitting;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Reset test state
 */
function reset() {
  delete test.count;
  delete test.time;
  delete test.running;
  test.<span class="apidocCodeKeywordSpan">emit</span>('reset', test);
  return test;
}

function clone() {
  var test = extend(new Test(name, f), test);
  return test.reset();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.getGoogleChart" id="apidoc.element.dot.jslitmus.getGoogleChart">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>getGoogleChart
        <span class="apidocSignatureSpan">(normalize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getGoogleChart(normalize) {
  var chart_title = [
    'Operations/second on ' + platform.name,
    '(' + platform.version + ' / ' + platform.os + ')'
  ];

  var n = tests.length, markers = [], data = [];
  var d, min = 0, max = -1e10;

  // Gather test data

  var markers = map(tests, function(test, i) {
    if (test.count) {
      var hz = test.getHz();
      var v = hz != Infinity ? hz : 0;
      data.push(v);
      var label = test.name + '(' + humanize(hz)+ ')';
      var marker = 't' + escape2(label) + ',000000,0,' + i + ',10';
      max = Math.max(v, max);

      return marker;
    }
  });

  if (markers.length &lt;= 0) return null;

  // Build labels
  var labels = [humanize(min), humanize(max)];

  var w = 250, bw = 15;
  var bs = 5;
  var h = markers.length*(bw + bs) + 30 + chart_title.length*20;

  var params = {
    chtt: escape(chart_title.join('|')),
    chts: '000000,10',
    cht: 'bhg',                     // chart type
    chd: 't:' + data.join(','),     // data set
    chds: min + ',' + max,          // max/min of data
    chxt: 'x',                      // label axes
    chxl: '0:|' + labels.join('|'), // labels
    chsp: '0,1',
    chm: markers.join('|'),         // test names
    chbh: [bw, 0, bs].join(','),    // bar widths
    // chf: 'bg,lg,0,eeeeee,0,eeeeee,.5,ffffff,1', // gradient
    chs: w + 'x' + h
  };

  var url = 'http://chart.apis.google.com/chart?' + join(params);

  return url;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		jslitmus.on('complete', function(test) {
		// Output test results
			currentSet.innerHTML += test + '&lt;br/&gt;';
		});
		// 'all_complete' fires when all tests have finished.
		jslitmus.on('all_complete', function() {
			// Get the results image URL
			var url = jslitmus.<span class="apidocCodeKeywordSpan">getGoogleChart</span>();
			if (currentSet.id === 'small') {
				currentSet.innerHTML += resultTmpl({size: snippet.length, url: url});
				setTimeout(function() {
					jslitmus.clearAll();
					currentSet = document.getElementById('large');
					for(var i=0; i&lt;8; i++) { snippet += snippet; }
					testsetup(snippet);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.on" id="apidoc.element.dot.jslitmus.on">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>on
        <span class="apidocSignatureSpan">(e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (e, f) {
  if (!listeners[e]) listeners[e] = [];
  listeners[e].push(f);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		doU = require('./templating/doU.js');
		doT = require('./templating/doT.js');
		var passOne = 0;
		console.log("*** Compilation speed test");
		console.log("*** Small template length: " + snippet.length);
		testsetup(snippet);
		// Log the test results
		jslitmus.<span class="apidocCodeKeywordSpan">on</span>('complete', function(test) {
			//console.log(util.inspect(process.memoryUsage()));
			console.log(test.toString());
		});
		// 'all_complete' fires when all tests have finished.
		jslitmus.on('all_complete', function() {
			switch (passOne) {
			case 0:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.removeAllListeners" id="apidoc.element.dot.jslitmus.removeAllListeners">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>removeAllListeners
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (e) {
  listeners[e] = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.removeListener" id="apidoc.element.dot.jslitmus.removeListener">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>removeListener
        <span class="apidocSignatureSpan">(e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (e, f) {
  listeners[e] = filter(listeners[e], function(l) {
    return l != f;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.runAll" id="apidoc.element.dot.jslitmus.runAll">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>runAll
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runAll(e) {
  forEach(tests, _queueTest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				break;
			default:
				return;
			}

			jslitmus.clearAll();
			testsetup(snippet);
			jslitmus.<span class="apidocCodeKeywordSpan">runAll</span>();
		});
		// Run it!
		jslitmus.runAll();
	}

	function runTestsInBrowser() {
		jslitmus = window.jslitmus;doU = window.doU;doT = window.doT;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.dot.jslitmus.test" id="apidoc.element.dot.jslitmus.test">
        function <span class="apidocSignatureSpan">dot.jslitmus.</span>test
        <span class="apidocSignatureSpan">(name, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function test(name, f) {
  // Create the Test object
  var test = new Test(name, f);
  tests.push(test);

  // Run the next test if this one finished
  test.on('*', function() {
    // Forward test events to jslitmus listeners
    var args = Array.prototype.slice.call(arguments);
    args.unshift(test._emitting);
    jslitmus.emit.apply(jslitmus, args);

    // Auto-run the next test
    if (test._emitting == 'complete') {
      currentTest = null;
      _nextTest();
    }
  });

  jslitmus.emit('added', test);

  return test;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	var defFolder = this.__path,
		sources = fs.readdirSync(defFolder),
		k, l, name;

	for( k = 0, l = sources.length; k &lt; l; k++) {
		name = sources[k];
		if (/\.def(\.dot|\.jst)?$/.<span class="apidocCodeKeywordSpan">test</span>(name)) {
			if (doT.log) console.log("Loaded def " + name);
			this.__includes[name.substring(0, name.indexOf('.'))] = readdata(defFolder + name);
		}
	}

	for( k = 0, l = sources.length; k &lt; l; k++) {
		name = sources[k];
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>